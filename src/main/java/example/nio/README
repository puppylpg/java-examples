https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html

学习nio：
1. Channel和Buffer：二者交互，看ChannelToChannel.java；
2. Buffer内部细节：position, limit, capacity;
3. Buffer的一些读写方法：put的重载方法&putInt等put族/get的重载方法&getInt等get族；
4. Buffer切片：指定好position和limit，slice()会按照这两个的值搞一个子缓冲区，使用的是原缓冲区的一部分，用途大概就是如果需要搞数组的一部分，就不用传start和length之类的参数了，直接切个片，处理整个子片就行了。
5. Scatter/Gather：往一堆buffer里读写数据，适用于协议；
6. 文件锁；
7. 异步io！！！nio！！！
8. Charset；

通道与流的不同之处在于通道是双向的。而流只是在一个方向上移动(一个流必须是 InputStream 或者 OutputStream 的子类)， 而 通道 可以用于读、写或者同时用于读写。
因为它们是双向的，所以通道可以比流更好地反映底层操作系统的真实情况。特别是在 UNIX 模型中，底层操作系统通道是双向的。

缓冲区实质上是一个数组。通常它是一个字节数组，但是也可以使用其他种类的数组。
但是一个缓冲区不 仅仅 是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。

使用nio的Buffer读取数据的一个很大好处是，只管读写就行了，Buffer里有position、limit等知道该读多少写多少，
不像普通io，如果底层buffer只读了一半，之前剩的一半没被清掉的话，输出的时候会一起输出出来。



总结：
正如您所看到的， NIO 库有大量的特性。在一些新特性（例如文件锁定和字符集）提供新功能的同时，许多特性在优化方面也非常优秀。
在基础层次上，通道和缓冲区可以做的事情几乎都可以用原来的面向流的类来完成。但是通道和缓冲区允许以 快得多 的方式完成这些相同的旧操作 ― 事实上接近系统所允许的最大速度。
不过 NIO 最强大的长处之一在于，它提供了一种在 Java 语言中执行进行输入/输出的新的（也是迫切需要的）结构化方式。
随诸如缓冲区、通道和异步 I/O 这些概念性（且可实现的）实体而来的，是我们重新思考 Java 程序中的 I/O过程的机会。
这样，NIO 甚至为我们最熟悉的 I/O 过程也带来了新的活力，同时赋予我们通过和以前不同并且更好的方式执行它们的机会。